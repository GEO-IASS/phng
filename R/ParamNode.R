#' @title Parameter Node Object
#' @format \code{\link{R6Class}} object
#'
#' @description
#' A \code{\link[R6]{R6Class}} to represent parameters.
#' 
#' @section Member Variables
#' @field id [\code{character}] \cr Unique id.
#' @field storage.type [\code{character(1)}] \cr How are values for this Parameter represented as an R object.
#' @field check [\code{function}] \cr A function that returns \code{TRUE} for valid parameter values and a \code{character} if the value is not valid.
#' @field assert [\code{function}] \cr A assertion generated by \code{\link[checkmate]{makeAssertionFunction}} from the \code{check} function.
#' @field test [\code{function}] \cr A test generated by \code{\link[checkmate]{makeTestFunction}} from the \code{check} function.
#' @field tags [\code{character}] \cr A vector of \code{characters} that indicate special properties of this Parameter.
#' 
#' @section Methods
#' @field sample(n) \cr Function to sample Parameter values. Always returns a \code{data.table}.
#' @field denorm(x) \cr Takes a named list. Each list item contains a numerical vector with values between \code{[0,1]}. These values will be mapped to values of the Parameter Space.
#' 
#'
#' @return [\code{\link{ParamNode}}].
#' @family ParamHelpers
ParamNode = R6Class("ParamNode",
  inherit = ParamBase,
  public = list(
   
    # member variables
    id = NULL, # string to uniquely identify this param
    handle = NULL, # additional stuff
    storage.type = NULL, # of what R data storage.type can values of this parameter be stored?
    check = NULL, # a checkmate check function to validate if a value is valid for this Param
    assert = NULL, # assertion generated from the above check
    test = NULL, # test generated from the above check
    tags = NULL, # additional properties like "on.train", "on.test" or "tunable" for mlr
    
    # constructor
    initialize = function(id, storage.type, check, handle = NULL, tags) {
      handle = handle %??% ParamHandle$new()
      assertString(id)
      self$id = assertNames(id, type = "strict")
      self$storage.type = assertString(storage.type)
      self$check = assertFunction(check)
      self$test = makeTestFunction(check)
      self$assert = makeAssertionFunction(check)
      self$handle = assertClass(handle, "ParamHandle")
      self$tags = assertCharacter(tags, null.ok = TRUE)
    },
    
    # public methods
    sample = function(n = 1L) {
      stop("sample not implemented")
    },
    denorm = function(x) {
      stop("denorm not implemented")
    }
  ),
  active = list(
    has.finite.bounds = function() NA
  )
)
